diff --git a/code/RtpQueue.cpp b/code/RtpQueue.cpp
index 0b1e044..e95b8fb 100644
--- a/code/RtpQueue.cpp
+++ b/code/RtpQueue.cpp
@@ -1,4 +1,4 @@
- #include "RtpQueue.h"
+#include "RtpQueue.h"
 #include <iostream>
 #include <string.h>
 using namespace std;
@@ -26,34 +26,38 @@ RtpQueue::RtpQueue() {
     sizeOfNextRtp_ = -1;
 }
 
-void RtpQueue::push(void *rtpPacket, int size, unsigned short seqNr, float ts) {
+bool RtpQueue::push(void *rtpPacket, int size, unsigned short seqNr,  bool isMark, float ts) {
     int ix = head+1;
     if (ix == kRtpQueueSize) ix = 0;
     if (items[ix]->used) {
       /*
       * RTP queue is full, do a drop tail i.e ignore new RTP packets
       */
-      return;
+      return (false);
     }
     head = ix;
     items[head]->seqNr = seqNr;
     items[head]->size = size;
     items[head]->ts = ts;
+    items[head]->isMark = isMark;
     items[head]->used = true;
     bytesInQueue_ += size;
     sizeOfQueue_ += 1;
-    memcpy(items[head]->packet, rtpPacket, size);
+    items[head]->packet = rtpPacket;
     computeSizeOfNextRtp();
+    return (true);
 }
-
-bool RtpQueue::pop(void *rtpPacket, int& size, unsigned short& seqNr) {
+bool RtpQueue::pop(void **rtpPacket, int& size, unsigned short& seqNr, bool &isMark)
+{
     if (items[tail]->used == false) {
+        *rtpPacket = NULL;
         return false;
         sizeOfNextRtp_ = -1;
     } else {
         size = items[tail]->size;
-        memcpy(rtpPacket,items[tail]->packet,size);
+        *rtpPacket = items[tail]->packet;
         seqNr = items[tail]->seqNr;
+        isMark = items[tail]->isMark;
         items[tail]->used = false;
         tail++; if (tail == kRtpQueueSize) tail = 0;
         bytesInQueue_ -= size;
@@ -98,23 +102,24 @@ float RtpQueue::getDelay(float currTs) {
         return currTs-items[tail]->ts;
     }
 }
-
+/*
 bool RtpQueue::sendPacket(void *rtpPacket, int& size, unsigned short& seqNr) {
     if (sizeOfQueue() > 0) {
-        pop(rtpPacket, size, seqNr);
+        bool isMark;
+        pop(rtpPacket, size, seqNr, isMark);
         return true;
     }
     return false;
 }
-
+*/
+extern void packet_free(void *buf);
 void RtpQueue::clear() {
-    for (int n=0; n < kRtpQueueSize; n++) {
-        items[n]->used = false;
+    uint16_t seqNr;
+    int size;
+    void *buf;
+    while (sizeOfQueue() > 0) {
+        bool isMark;
+        pop(&buf, size, seqNr, isMark);
+        packet_free(buf);
     }
-    head = -1;
-    tail = 0;
-    nItems = 0;
-    bytesInQueue_ = 0;
-    sizeOfQueue_ = 0;
-    sizeOfNextRtp_ = -1;
 }
diff --git a/code/RtpQueue.h b/code/RtpQueue.h
index 175d175..1a6f07f 100644
--- a/code/RtpQueue.h
+++ b/code/RtpQueue.h
@@ -20,10 +20,11 @@ public:
 class RtpQueueItem {
 public:
     RtpQueueItem();
-    char packet[2000];
+    void* packet;
     int size;
     unsigned short seqNr;
     float ts;
+    bool isMark;
     bool used;
 };
 
@@ -32,8 +33,8 @@ class RtpQueue : public RtpQueueIface {
 public:
     RtpQueue();
 
-    void push(void *rtpPacket, int size, unsigned short seqNr, float ts);
-    bool pop(void *rtpPacket, int &size, unsigned short &seqNr);
+    bool push(void *rtpPacket, int size, unsigned short seqNr, bool isMark, float ts);
+    bool pop(void **rtpPacket, int &size, unsigned short &seqNr, bool &isMark);
     int sizeOfNextRtp();
     int seqNrOfNextRtp();
     int bytesInQueue(); // Number of bytes in queue
diff --git a/code/scream_sender.cpp b/code/scream_sender.cpp
index 4e6f141..2ac54aa 100644
--- a/code/scream_sender.cpp
+++ b/code/scream_sender.cpp
@@ -92,9 +92,9 @@ RtpQueue *rtpQueue = 0;
 
 // We don't bother about SSRC in this implementation, it is only one stream
 
-char *DECODER_IP = "192.168.0.21";
+const char *DECODER_IP = "192.168.0.21";
 int DECODER_PORT = 30110;
-char *DUMMY_IP = "217.10.68.152"; // Dest address just to punch hole in NAT
+const char *DUMMY_IP = "217.10.68.152"; // Dest address just to punch hole in NAT
 
 int SIERRA_PYTHON_PORT = 35000;
 
@@ -103,13 +103,10 @@ struct sockaddr_in incoming_rtcp_addr;
 struct sockaddr_in dummy_rtcp_addr;
 struct sockaddr_in sierra_python_addr;
 
-unsigned char buf_rtp[BUFSIZE];     /* receive buffer RTP packets */
-
 unsigned char buf_rtcp[BUFSIZE];     /* receive buffer RTCP packets*/
 
 unsigned char buf_sierra[BUFSIZE];     /* receive buffer RTCP packets*/
 
-
 socklen_t addrlen_outgoing_rtp;
 socklen_t addrlen_dummy_rtcp;
 uint32_t lastLogT_ntp = 0;
@@ -141,6 +138,11 @@ long getTimeInUs(){
   return us;
 }
 */
+
+void packet_free(void *buf) {
+    free(buf);
+}
+
 uint32_t getTimeInNtp() {
 	struct timeval tp;
 	gettimeofday(&tp, NULL);
@@ -200,6 +202,7 @@ void sendPacket(void* buf, int size) {
 void *transmitRtpThread(void *arg) {
 	int size;
 	uint16_t seqNr;
+    bool isMark;
 	char buf[2000];
 	uint32_t time_ntp = getTimeInNtp();
 	int sleepTime_us = 10;
@@ -239,13 +242,16 @@ void *transmitRtpThread(void *arg) {
 				if (retVal > 0.0f)
 					accumulatedPaceTime += retVal;
 				if (retVal != -1.0) {
+                    void *buf;
 					pthread_mutex_lock(&lock_rtp_queue);
-					rtpQueue->pop(buf, size, seqNr);
+					rtpQueue->pop(&buf, size, seqNr, isMark);
 					sendPacket(buf, size);
 					pthread_mutex_unlock(&lock_rtp_queue);
+                    packet_free(buf);
+                    buf = NULL;
 					pthread_mutex_lock(&lock_scream);
 					time_ntp = getTimeInNtp();
-					retVal = screamTx->addTransmitted(time_ntp, SSRC, size, seqNr, (buf[1] & 0x80) != 0);
+					retVal = screamTx->addTransmitted(time_ntp, SSRC, size, seqNr, isMark);
 					pthread_mutex_unlock(&lock_scream);
 				}
 
@@ -395,18 +401,25 @@ void *createRtpThread(void *arg) {
 
 			bytes = std::max(0, bytes - pl_size);
 			unsigned char pt = PT;
+            bool isMark;
 			if (bytes == 0) {
 				// Last RTP packet, set marker bit
 				pt |= 0x80;
-			}
+                isMark = true;
+			} else {
+                isMark = false;
+            }
+            uint8_t *buf_rtp = (uint8_t *)malloc(BUFSIZE);
 			writeRtp(buf_rtp, seqNr, ts, pt);
 
 			if (pushTraffic) {
 				sendPacket(buf_rtp, recvlen);
+                packet_free(buf_rtp);
+                buf_rtp = NULL;
 			}
 			else {
 				pthread_mutex_lock(&lock_rtp_queue);
-				rtpQueue->push(buf_rtp, recvlen, seqNr, (time_ntp) / 65536.0f);
+				rtpQueue->push(buf_rtp, recvlen, seqNr, isMark, (time_ntp) / 65536.0f);
 				pthread_mutex_unlock(&lock_rtp_queue);
 
 				pthread_mutex_lock(&lock_scream);
